\chapter{Pipelines}\label{chapter: pipelines}

\begin{enumerate}
  \item \textbf{Vertex}: The majority of transformation pipeline happens here,
  \textbf{except W2V}
  \begin{itemize}
    \item Programmable through shader
    \item Produces vertices in \textbf{clip space} (a arbitrary region defined
    by graphics APIs in which triangles are drawn)
  \end{itemize}

  \item \textbf{Rasterization}: produces a set of fragments (which are
  potential pixels); fragments have
  \begin{itemize}
    \item Location in frame buffer (screen location)
    \item Color
    \item Depth
  \end{itemize}

  \item \textbf{Fragment}: the fragment shader would finalize the color
  produced by the rasterization stage
  \begin{itemize}
    \item Not pixels: each fragment has a 2D location in a raster and a color;
    final value is found by appliying hidden surface removal and possibly
    compositing to a set of fragments
    \item Programmable through shader
  \end{itemize}
\end{enumerate}

\section{Transformation Pipeline}

  \begin{equation}
    \begin{bmatrix}
      x_{s} \\
      y_{s} \\
      0 \\
      1
    \end{bmatrix}
    =
    \begin{bmatrix}
      \text{W2V}
    \end{bmatrix}
    \begin{bmatrix}
      \text{Projection}
    \end{bmatrix}
    \begin{bmatrix}
      \text{View}
    \end{bmatrix}
    \begin{bmatrix}
      \text{Model}
    \end{bmatrix}
    \begin{bmatrix}
      x_{m} \\
      y_{m} \\
      z_{m} \\
      1
    \end{bmatrix}
  \end{equation}

  Transforming model coordinate system to viewport coordinate system
  (\textbf{note that transformations occur from right to left})

  \begin{itemize}
    \item Mostly done on GPU (except \textbf{W2V})
    \item GPU parts are done through the vertex shader
    \item Can also handle colors
  \end{itemize}

  \paragraph{Stages}
  \begin{itemize}
    \item The \textbf{model matrix} map local object coordinates to
    world coordinates (ex. rotation)
    \item Given a camera looking down the z-axis from the origin,
    the \textbf{view matrix} map world coordinates to camera coordinates,
    where camera sits at the origin
    \item The \textbf{projection matrix} map camera coordinates to canonical
    view volume (basically 2D)
    \item The \textbf{W2V (window to view) matrix} map canonical view volume
    to screen space; steps
    \begin{enumerate}
      \item \textbf{Clipping}: only draw stuff in clip space
      \item \textbf{Homogeneous divide}
      \item \textbf{Widnow to view port}: transform from clip coordinates
      (aka. window coordinates $ -1 \to 1 $) to viewport space
    \end{enumerate}
  \end{itemize}

  \textbf{Every transformations except W2V transformation happen in vertex
  processing stage}

  \subsection{In Unity}

    \begin{itemize}
      \item Transform component on a camera is the view matrix
      \item Camera settings are used to create
      \begin{itemize}
        \item Projection matrix
        \item Viewport matrix
      \end{itemize}
    \end{itemize}

\section{Stage - View}

  \begin{align}
    V &=
    \begin{bmatrix}
      u & v & w & e \\
      0 & 0 & 0 & 1
    \end{bmatrix}^{-1} \\
    &=
    \begin{bmatrix}
      x_{u} & y_{u} & z_{u} & 0 \\
      x_{v} & y_{v} & z_{v} & 0 \\
      x_{w} & y_{w} & z_{w} & 0 \\
      0 & 0 & 0 & 1
    \end{bmatrix}
    \begin{bmatrix}
      1 & 0 & 0 & -x_{e} \\
      0 & 1 & 0 & -y_{e} \\
      0 & 0 & 1 & -z_{e} \\
      0 & 0 & 0 & 1
    \end{bmatrix} \\
    l &= \text{look at point } - \text{ eye point}
  \end{align}

  \begin{itemize}
    \item $ \vec{u} $: right; assuming $ t $ is top
    \begin{equation}
      u = \frac{t \times w}{\left| t \times w \right|}
    \end{equation}

    \item $ \vec{v} $: top
    \begin{equation}
      v = w \times u
    \end{equation}

    \item $ \vec{w} $: forward
    \begin{equation}
      w = - \frac{l}{\left| l \right|}
    \end{equation}
    $ - $ is needed when dealing with systems where negative is closer to the
    screen

    \item $ \vec{e} $: position
  \end{itemize}

  \subsection{Deriving View Matrix}

    \begin{enumerate}
      \item Translate the eyepoint to the origin
      \item Rotate so that:
      \begin{itemize}
        \item lookat vector aligns with $ â€“z $ axis (OpenGL/WebGL)
        \item up aligns with y
      \end{itemize}

      \item We move all objects (the world) this way...
    \end{enumerate}

\section{Stage - Projection}

  Projection refers to the process of reducing dimensionality. There are two
  modes of projection

  \begin{itemize}
    \item \textbf{Orthographic}: toss out the z component
    \item \textbf{Perspective}: scale decreases as distance increases
  \end{itemize}

  \subsection{Orthographic Projection}

    \paragraph{Matrix}
    \begin{equation}
      P =
      \begin{bmatrix}
        \frac{2}{r - l} & 0 & 0 & -\frac{r + l}{r - l} \\
        0 & \frac{2}{t - b} & 0 & -\frac{t + b}{t - b} \\
        0 & 0 & \frac{-2}{f - n} & -\frac{f + n}{f - n} \\
        0 & 0 & 0 & 1 \\
      \end{bmatrix}
    \end{equation}

    \begin{itemize}
      \item $ r $: right
      \item $ l $: left
      \item $ t $: top
      \item $ b $: bottom
      \item $ f $: far
      \item $ n $: near
    \end{itemize}

  \subsection{Perspective Projection}

    \paragraph{Matrix}
    \begin{equation}
      P =
      \begin{bmatrix}
        \frac{n}{2} & 0 & 0 & 0 \\
        0 & \frac{n}{t} & 0 & 0 \\
        0 & 0 & \frac{-f}{f - n} & \frac{-fn}{f - n} \\
        0 & 0 & -1 & 0 \\
      \end{bmatrix}
    \end{equation}

    \begin{itemize}
      \item $ r $: right
      \item $ t $: top
      \item $ n $: near
      \item $ f $: far
    \end{itemize}

    \href{http://www.songho.ca/opengl/gl_projectionmatrix.html}{Deriving
    the matrix}

    \paragraph{Equation}
    \begin{align}
      \frac{y_{\text{clip}}}{d} &= \frac{y_{\text{view}}}{-z_{\text{view}}} \\
      y_{\text{clip}}
      &= d\frac{y_ {\text{view}}}{-z_{\text{view}}} \\
      &= \frac{y_{\text{view}}}{-z_{\text{view}} / d}
    \end{align}

    \begin{itemize}
      \item The equation applies in situations where
      \begin{itemize}
        \item The \textbf{eyes} are \textbf{centered at the origin}
        \item The \textbf{view} is in \textbf{negative z direction}
        \item The clip is between the eyes and the view
      \end{itemize}

      \item $ d $: distance from eyes to the screen (clip)
      \item This equation also applies to $ x $ and $ y $
    \end{itemize}

\section{Stage - Window to Viewport}

  This is the transformation used by WebGL and DirectX

  \begin{align}
    \text{W2V } &=
    \begin{bmatrix}
      \frac{w - 1}{2} & 0 & 0 \\
      0 & \frac{h - 1}{2} & 0 \\
      0 & 0 & 1
    \end{bmatrix}
    \begin{bmatrix}
      1 & 0 & 1 \\
      0 & 1 & 1 \\
      0 & 0 & 1
    \end{bmatrix}
    \begin{bmatrix}
      x \\
      y \\
      1
    \end{bmatrix} \\
    &=
    \begin{bmatrix}
      \frac{w - 1}{2} & 0 & \frac{w - 1}{2} \\
      0 & \frac{h - 1}{2} & \frac{h - 1}{2} \\
      0 & 0 & 1
    \end{bmatrix}
    \begin{bmatrix}
      x \\
      y \\
      1
    \end{bmatrix}
  \end{align}

  From right to left:

  \begin{enumerate}
    \item Translate lower left corner to $ \left( 0, 0 \right) $
    \item Translate upper right corner from $ \left( 2, 2 \right) $ (after step
    1) to $ \left( w - 1, h - 1 \right) $
  \end{enumerate}

  \subsection{Continuous Space}

    Even though pixels are discrete units (you can't have half of a pixel),
    it can be helpful to still consider pixel spaces to be continuous; WebGL
    and DirectX considers pixel centers to be
    $ \left( x + 0.5, y + 0.5 \right) $

\section{Hidden Surface Removal}

  \begin{itemize}
    \item \textbf{Painter's algorithm}: draw farther object first
    \begin{itemize}
      \item Expensive to sort
      \item Depth cycle
    \end{itemize}

    \item \textbf{Z-Buffer}: keep a z buffer on pixels, while drawing,
    only write to pixel if the object being drawn has a z value that is
    closer than the z value of the pixel
    \begin{itemize}
      \item More popular today; not used in the past for memory issues
      \item If two z values are too close, it's hard to determine which is
      closer
    \end{itemize}

    \item \textbf{Aka. depth test}
  \end{itemize}
